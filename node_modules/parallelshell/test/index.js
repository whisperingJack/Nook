(function() {
  var Promise, chai, cmdWrapper, failingProcess, killPs, sh, shArg, should, spawn, spawnParallelshell, spyOnPs, testOutput, usageInfo, verbose, waitingProcess;

  chai = require("chai");

  should = chai.should();

  spawn = require("child_process").spawn;

  Promise = require("bluebird");

  verbose = 0;

  if (process.platform === "win32") {
    sh = "cmd";
    shArg = "/c";
  } else {
    sh = "sh";
    shArg = "-c";
  }

  waitingProcess = "\"node -e 'setTimeout(function(){},10000);'\"";

  failingProcess = "\"node -e 'throw new Error();'\"";

  usageInfo = "-h, --help         output usage information\n-v, --verbose      verbose logging\n-w, --wait         will not close sibling processes on error".split("\n");

  cmdWrapper = function(cmd) {
    if (process.platform !== "win32") {
      cmd = "exec " + cmd;
    }
    if (verbose) {
      console.log("Calling: " + cmd);
    }
    return cmd;
  };

  spawnParallelshell = function(cmd) {
    return spawn(sh, [shArg, cmdWrapper("node ./index.js " + cmd)], {
      cwd: process.cwd
    });
  };

  killPs = function(ps) {
    return ps.kill("SIGINT");
  };

  spyOnPs = function(ps, verbosity) {
    if (verbosity == null) {
      verbosity = 1;
    }
    if (verbose >= verbosity) {
      ps.stdout.setEncoding("utf8");
      ps.stdout.on("data", function(data) {
        return console.log(data);
      });
      ps.stderr.setEncoding("utf8");
      return ps.stderr.on("data", function(data) {
        return console.log("err: " + data);
      });
    }
  };

  testOutput = function(cmd, expectedOutput) {
    return new Promise(function(resolve) {
      var output, ps;
      ps = spawnParallelshell(cmd);
      spyOnPs(ps, 3);
      ps.stdout.setEncoding("utf8");
      output = [];
      ps.stdout.on("data", function(data) {
        var lines;
        lines = data.split("\n");
        if (lines[lines.length - 1] === "") {
          lines.pop();
        }
        return output = output.concat(lines);
      });
      return ps.stdout.on("end", function() {
        var i, line, _i, _len;
        for (i = _i = 0, _len = expectedOutput.length; _i < _len; i = ++_i) {
          line = expectedOutput[i];
          line.should.equal(output[i]);
        }
        return resolve();
      });
    });
  };

  describe("parallelshell", function() {
    it("should print on -h and --help", function(done) {
      return Promise.all([testOutput("-h", usageInfo), testOutput("--help", usageInfo)]).then(function() {
        return done();
      })["catch"](done);
    });
    it("should close with exitCode 1 on child error", function(done) {
      var ps;
      ps = spawnParallelshell(failingProcess);
      spyOnPs(ps, 2);
      return ps.on("close", function() {
        ps.exitCode.should.equal(1);
        return done();
      });
    });
    it("should run with a normal child", function(done) {
      var ps;
      ps = spawnParallelshell(waitingProcess);
      spyOnPs(ps, 1);
      ps.on("close", function() {
        ps.signalCode.should.equal("SIGINT");
        return done();
      });
      return setTimeout((function() {
        should.not.exist(ps.signalCode);
        return killPs(ps);
      }), 50);
    });
    it("should close sibling processes on child error", function(done) {
      var ps;
      ps = spawnParallelshell([waitingProcess, failingProcess, waitingProcess].join(" "));
      spyOnPs(ps, 2);
      return ps.on("close", function() {
        ps.exitCode.should.equal(1);
        return done();
      });
    });
    it("should wait for sibling processes on child error when called with -w or --wait", function(done) {
      var ps, ps2;
      ps = spawnParallelshell(["-w", waitingProcess, failingProcess, waitingProcess].join(" "));
      ps2 = spawnParallelshell(["--wait", waitingProcess, failingProcess, waitingProcess].join(" "));
      spyOnPs(ps, 2);
      spyOnPs(ps2, 2);
      setTimeout((function() {
        should.not.exist(ps.signalCode);
        should.not.exist(ps2.signalCode);
        killPs(ps);
        return killPs(ps2);
      }), 50);
      return Promise.all([
        new Promise(function(resolve) {
          return ps.on("close", resolve);
        }), new Promise(function(resolve) {
          return ps2.on("close", resolve);
        })
      ]).then(function() {
        return done();
      })["catch"](done);
    });
    return it("should close on CTRL+C / SIGINT", function(done) {
      var ps;
      ps = spawnParallelshell(["-w", waitingProcess, failingProcess, waitingProcess].join(" "));
      spyOnPs(ps, 2);
      ps.on("close", function() {
        ps.signalCode.should.equal("SIGINT");
        return done();
      });
      return killPs(ps);
    });
  });

}).call(this);
