(function() {
  var S, async, compressor, fs, getCompressor, getFileExt, minify, minifyDefaultOptions, path, util, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  fs = require('fs-extra');

  path = require('path');

  compressor = require('node-minify');

  async = require('async');

  S = require('string');

  util = require('./util');

  minifyDefaultOptions = ['--mangle'];

  exports.makeGroups = function(files) {
    var groupedFiles;
    groupedFiles = {};
    _.each(files, function(file) {
      var groupFiles, typeFiles, _name, _name1, _ref;
      if (groupedFiles[_name = file.type] == null) {
        groupedFiles[_name] = {};
      }
      typeFiles = groupedFiles[file.type];
      if (typeFiles[_name1 = file.group] == null) {
        typeFiles[_name1] = [];
      }
      groupFiles = typeFiles[file.group];
      if (_ref = file.path, __indexOf.call(groupFiles, _ref) < 0) {
        return groupFiles.push(file.path);
      }
    });
    return groupedFiles;
  };

  getCompressor = function(type, options) {
    var compress, fallback;
    fallback = ['no-compress', []];
    switch (type) {
      case 'script':
        compress = options.minify || options.minifyJs;
        if (compress) {
          return ['uglifyjs', ['--mangle']];
        } else {
          return fallback;
        }
        break;
      case 'link':
        compress = options.minify || options.minifyCss;
        if (compress) {
          return ['yui-css', []];
        } else {
          return fallback;
        }
        break;
      default:
        return fallback;
    }
  };

  getFileExt = function(type) {
    switch (type) {
      case 'script':
        return 'js';
      case 'link':
        return 'css';
      default:
        return '';
    }
  };

  minify = function(options, callback) {
    var meta;
    meta = options.meta;
    delete options.meta;
    _.extend(options, {
      callback: function(err, min) {
        return callback(err, _.extend(meta, {
          file: options.fileOut,
          content: min
        }));
      }
    });
    return new compressor.minify(options);
  };

  exports.concatenateFiles = function($, options, groupedFiles, callback) {
    var tasks;
    tasks = [];
    _.each(groupedFiles, function(groups, type) {
      return _.each(groups, function(files, group) {
        var ext, minType, minifyOptions, outFile, pathPrefix, _ref, _ref1, _ref2, _ref3;
        ext = getFileExt(type);
        pathPrefix = (_ref = options["" + ext + "Prefix"]) != null ? _ref : ext;
        if (options.minify) {
          ext = "min." + ext;
        }
        outFile = path.join((_ref1 = options.outdir) != null ? _ref1 : options.basepath, pathPrefix, "" + group + "." + ext);
        if (fs.existsSync(outFile)) {
          fs.unlinkSync(outFile);
        }
        fs.ensureDirSync(path.dirname(outFile));
        files = _.map(files, function(f) {
          return path.join(options.basepath, f);
        });
        _ref2 = getCompressor(type, options), minType = _ref2[0], minifyOptions = _ref2[1];
        return tasks.push({
          type: minType,
          options: minifyOptions.concat(_.isArray(options.minify) ? options.minify : []),
          fileIn: files,
          fileOut: outFile,
          tempPath: (_ref3 = options.tempPath) != null ? _ref3 : '/tmp/',
          meta: {
            type: type,
            group: group,
            pathPrefix: pathPrefix
          }
        });
      });
    });
    return async.map(tasks, minify, function(err, results) {
      return callback(err, results);
    });
  };

  exports.replaceTags = function($, options, results) {
    return _.each(results, function(result) {
      var $elem, $elems, $first, basepath, filepath, firstSrc, _ref;
      $elems = $("" + result.type + "[group=" + result.group + "]");
      $first = $elems.first();
      firstSrc = $first.attr(util.getSrcProperty(result.type));
      if (options.httpBasepath) {
        basepath = path.join(options.httpBasepath, options.pathPrefix);
      } else {
        basepath = (_ref = options.outdir) != null ? _ref : options.basepath;
      }
      filepath = result.file.replace(basepath, '');
      if (firstSrc[0] !== '/') {
        filepath = S(filepath).chompLeft('/').s;
      }
      $elem = $elems.first().clone().attr(util.getSrcProperty(result.type), filepath).attr('group', null);
      $elems.first().before($.html($elem));
      return $elems.remove();
    });
  };

  exports.concatAndMinify = function($, options, callback) {
    var files, groupedFiles, groups;
    groups = $('*[group]');
    files = _.map(groups, function(g) {
      var $g;
      $g = $(g);
      return {
        group: $g.attr('group'),
        path: $g.attr(util.getSrcProperty(g.name)),
        type: g.name
      };
    });
    groupedFiles = exports.makeGroups(files);
    return exports.concatenateFiles($, options, groupedFiles, function(err, results) {
      exports.replaceTags($, options, results);
      return callback($);
    });
  };

}).call(this);
